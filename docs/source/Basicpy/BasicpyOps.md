<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `basicpy.as_i1` (::mlir::CHOPPER::Basicpy::AsI1Op)

Evaluates an input to an i1 predicate value


Syntax:

```
operation ::= `basicpy.as_i1` $operand attr-dict `:` type($operand)
```

Applies the rules for interpreting a type as a boolean, returning an i1
indicating the truthiness of the operand. Since the output of this op
is intended to drive lower-level control flow, the i1 type is used (not
the user level BoolType).

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 1-bit signless integer

### `basicpy.binary_compare` (::mlir::CHOPPER::Basicpy::BinaryCompareOp)

Performs a comparison between two operands


Syntax:

```
operation ::= `basicpy.binary_compare` $left $operation $right attr-dict `:` type(operands)
```

This op performs only one step of a potentially multi-step short
circuit comparison.
See: https://docs.python.org/3/reference/expressions.html#comparisons

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`operation` | ::mlir::StringAttr | Comparison operator

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`left` | any type
`right` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Bool type

### `basicpy.binary_expr` (::mlir::CHOPPER::Basicpy::BinaryExprOp)

Binary expression


Syntax:

```
operation ::= `basicpy.binary_expr` $left $operation $right attr-dict `:` functional-type(operands, results)
```

An expression between two operands as generated by the AST BinOp node.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`operation` | ::mlir::StringAttr | Operation for a binary expression

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`left` | any type
`right` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | any type

### `basicpy.bool_cast` (::mlir::CHOPPER::Basicpy::BoolCastOp)

Casts between BoolType and i1 (predicate value)


Syntax:

```
operation ::= `basicpy.bool_cast` $operand attr-dict `:` type(operands) `->` type(results)
```

When interfacing with lower level dialect or progressively lowering
the Python BoolType away, it is often necessary to cast between it and
i1, which is used to represent bool-ness at lower levels.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | Python bool or i1

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Python bool or i1

### `basicpy.bool_constant` (::mlir::CHOPPER::Basicpy::BoolConstantOp)

A boolean constant


Syntax:

```
operation ::= `basicpy.bool_constant` $value attr-dict
```

A constant of type !basicpy.BoolType that can take either an i1 value
of 0 (False) or 1 (True).

Note that as in Python a BoolType can be thought of as an object, whereas
the corresponding i1 is a numeric type suitable for use in contexts where
storage format matters (or for interop with lower level dialects).

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`value` | ::mlir::IntegerAttr | 1-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Bool type

### `basicpy.build_dict` (::mlir::CHOPPER::Basicpy::BuildDictOp)

Builds an empty dict


Syntax:

```
operation ::= `basicpy.build_dict` attr-dict `:` functional-type(operands, results)
```

This op mirrors the CPython BUILD_MAP op (note naming difference).

Note that as with CPython, this op only builds an empty dict; however,
it is reserved in the future for it to take variadic operands to construct
with a list of key/value pairs.

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Dict type

### `basicpy.build_list` (::mlir::CHOPPER::Basicpy::BuildListOp)

Builds a list from operands


Syntax:

```
operation ::= `basicpy.build_list` operands attr-dict `:` functional-type(operands, results)
```

Constructs a new list object from its operands.

TODO: Any allowable type can be expressed in lists; however, this should be
revisited once more of the dialect infrastructure is in place and tightened
up accordingly. At that time, appropriate constraints should be added that
both allow correct program representation and support transformations to
lower levels (i.e. allowing a wider set of types as useful for conversions).

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`elements` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | List type

### `basicpy.build_tuple` (::mlir::CHOPPER::Basicpy::BuildTupleOp)

Builds a tuple from operands


Syntax:

```
operation ::= `basicpy.build_tuple` operands attr-dict `:` functional-type(operands, results)
```

Constructs a new tuple object from its operands.

TODO: Any allowable type can be expressed in lists; however, this should be
revisited once more of the dialect infrastructure is in place and tightened
up accordingly. At that time, appropriate constraints should be added that
both allow correct program representation and support transformations to
lower levels (i.e. allowing a wider set of types as useful for conversions).

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`elements` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Tuple type

### `basicpy.bytes_constant` (::mlir::CHOPPER::Basicpy::BytesConstantOp)

Constant bytes value


Syntax:

```
operation ::= `basicpy.bytes_constant` $value attr-dict
```

A bytes value of BytesType. The value is represented by a StringAttr.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`value` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Bytes type

### `basicpy.exec_discard` (::mlir::CHOPPER::Basicpy::ExecDiscardOp)

Terminator for an exec block


Syntax:

```
operation ::= `basicpy.exec_discard` operands attr-dict `:` type(operands)
```

Discards results and terminates an exec block.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | any type

### `basicpy.exec` (::mlir::CHOPPER::Basicpy::ExecOp)

Evaluates an expression being executed as a statement

The result is discarded. Typically expressions are no-side-effect and can
be re-ordered as needed. Embedding one in an exec op ensures that its
placement in program order is preserved.

### `basicpy.func_template_call` (::mlir::CHOPPER::Basicpy::FuncTemplateCallOp)

Calls a function template


Syntax:

```
operation ::= `basicpy.func_template_call` $callee `(` $args `)` `kw` $arg_names attr-dict `:` functional-type($args, results)
```

Most function calls start with this generic calling op, which binds
symbolically to a func_template. At this level, there are very few
semantics associated with the call, since, often, both types and the
specific concrete callee cannot be determined.

Per python calling conventions, all functions return one result, even if
None or a tuple (which may be syntactically unpacked to multiple results).

If specified, the `argNames` operand is right aligned to the list of
positional `args`, representing arguments that are special or have been
passed with a keyword. The following arg names are special:
  '*': Indicates that the argument is a positional argument pack (must be
       the first arg name, if present).
  '**': Indicates that the argument is a keyword argument pack (must be
       the last arg name, if present).

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
`arg_names` | ::mlir::ArrayAttr | string array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`args` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | any type

### `basicpy.func_template` (::mlir::CHOPPER::Basicpy::FuncTemplateOp)

Group of multiple overload-resolved concrete functions

The outer func_template op acts as a module that can contain named concrete
functions that are interpreted as overloads. If the function signature is
sufficient to disambiguate (i.e. with nothing more than arity and MLIR
argument types), then this is all that is needed. However, in many cases,
additional attributes will need to be specified to further constrain types.
The first matching function signature is selected to satisfy a
`func_template_call` op.

TODO: Define this extended constraint matching.

Instantiation
-------------
Once a concrete function is selected as being applicable to a given call,
it will typically be instantiated as a standalone, unspecialized function
in the calling module (as a peer to the func_template). This function
will be uniquely identified by concating the outer func_template's symbol
name, '$', and the concrete instance's symbol name.

Note that the function may still be unspecialized (in that it contains
UnknownType arguments/results), and type inference is expected to further
specialize/inline/constrain it.

Naming
------
By convention, func_templates are named to avoid collision for various
uses:
  - Global function templates: "__global$python.qualified.name"
  - Method names: "__method$method_name"
  - Attribute getter: "__getattr$attr_name"
  - Attribute setter: "__setattr$attr_name"

As in user-level python, for functions that bind to an instance, the first
argument must be a concrete type for the bound instance type. In this way,
there is one `func_template` for every unique member name and the normal
type constraints system is used to select the overload, just as if it was
a normal function call. It is left to utility routines to merge libraries
in a way that preserves this invariant.

TODO: This needs to be fleshed out more as some additional rules about
ordering and conflict resolution are likely needed to make this correct.

Correlation with python runtime
-------------------------------
When extracting a program, it is typically necessary to create weak
references to specific python functions and correlate them back to a named
template defined here. Often times this can just be done lexically, but
to avoid fragility, any func_template that correlates to a python
runtime function will have an additional attribute `py_bind` that is an
array of StringAttr qualified names to resolve and bind to in the python
runtime. In cases of divergence, the symbol name of the template should
be chosen just for uniqueness (not significance).

The qualified name format for `py_bind` attribute is:
    package.name#local.qualified.name

### `basicpy.func_template_terminator` (::mlir::CHOPPER::Basicpy::FuncTemplateTerminatorOp)

Terminator pseudo-op for the FuncTemplateOp


### `basicpy.numeric_constant` (::mlir::CHOPPER::Basicpy::NumericConstantOp)

A constant from the Python3 numeric type hierarchy

Basicpy re-uses core MLIR types to represent the Python3 numeric type
hierarchy with the following mappings:

* Python3 `int` : In python, this type is signed, arbitrary precision but
  in typical realizations, it maps to an MLIR `IntegerType` of a fixed
  bit-width (typically si64 if no further information is known). In the
  future, there may be a real `Basicpy::IntType` that retains the true
  arbitrary precision nature, but this is deemed an enhancement that
  does not obviate the need to infer physical, sized types for many
  real-world cases. As such, the Basicpy numeric type hierarchy will
  always include physical `IntegerType`, if only to enable progressive
  lowering and interop with cases where the precise type is known.
* Python3 `float` : This is allowed to map to any legal floating point
  type on the physical machine and is usually represented as a double (f64).
  In MLIR, any `FloatType` is allowed, which facilitates progressive
  lowering and interop with cases where a more precise type is known.
* Python3 `complex` : Maps to an MLIR `ComplexType` with a `FloatType`
  elementType (note: in Python, complex numbers are always defined with
  floating point components).
* `bool` : See `bool_constant` for a constant (i1) -> !basicpy.BoolType
  constant. This constant op is not used for representing such bool
  values, even though from the Python perspective, bool is part of the
  numeric hierarchy (the distinction is really only necessary during
  promotion).

### Integer Signedness

All `int` values in Python are signed. However, there exist special cases
where libraries (i.e. struct packing and numpy arrays) interoperate with
unsigned values. As such, when mapping to MLIR, Python integer types
are represented as either signed or unsigned `IntegerType` types and can
be lowered to signless integers as appropriate (typically during realization
of arithmetic expressions where the choice is meaningful). Since it is not
known at the outset when in lowering this information is safe to discard
this `numeric_constant` op accepts any signedness.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`value` | ::mlir::Attribute | any attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | any type

### `basicpy.singleton` (::mlir::CHOPPER::Basicpy::SingletonOp)

Constant value for a singleton type


Syntax:

```
operation ::= `basicpy.singleton` attr-dict `:` type($result)
```

Some types only have a single possible value, represented by the
SingletonAttr. This op allows creating constants of these types.

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | None type or Ellipsis type

### `basicpy.slot_object_get` (::mlir::CHOPPER::Basicpy::SlotObjectGetOp)

Gets a slot from a slot object

Gets a slot from a SlotObject.

Example:
  %0 = basicpy.slot_object_make ...
  %1 = basicpy.slot_object_get %0[1] : !basicpy.SlotObject<...>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`index` | ::mlir::IntegerAttr | index attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`object` | Slot object

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | any type

### `basicpy.slot_object_make` (::mlir::CHOPPER::Basicpy::SlotObjectMakeOp)

Creates an instance of a SlotObject type

SlotObjects are typically instances of built-in classes that have a fixed
number of slots. Unlike in standard python, the types of each slot are
tracked.

This op has a custom assembly form which can be used when valid that
omits the operand types (since they are equal to the types in the returned
slot object). Example:
  %0 = basicpy.singleton : !basicpy.NoneType
  %1 = basicpy.slot_object_make(%0) ->
      !basicpy.SlotObject<slice, !basicpy.NoneType>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`slots` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Slot object

### `basicpy.str_constant` (::mlir::CHOPPER::Basicpy::StrConstantOp)

Constant string value


Syntax:

```
operation ::= `basicpy.str_constant` $value attr-dict
```

A string value of StrType. The value is represented by a StringAttr
that is UTF-8 encoded.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`value` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | String type

### `basicpy.unknown_cast` (::mlir::CHOPPER::Basicpy::UnknownCastOp)

Casts to and from the UnknownType


Syntax:

```
operation ::= `basicpy.unknown_cast` operands attr-dict `:` type(operands) `->` type(results)
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | any type

