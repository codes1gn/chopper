==============================
Pass And Transforms
==============================

CHOPPERConversionPasses
==============================

.. raw:: html

   <!-- Autogenerated by mlir-tblgen; don't manually edit -->

``-convert-basicpy-to-std``: Convert representable Basicpy ops to std
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``-convert-numpy-to-tcf``: Convert the numpy dialect to supported TCF ops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``-convert-tcf-to-linalg``: Convert TCF to Linalg
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The intention is for this pass to convert mainly to linalg named ops.

Because linalg is at the "TCP" layer of abstraction, this pass has to
concern itself with generating guards for error cases. ###
``-convert-tcf-to-std``: Convert TCF to Std ### ``-convert-tcf-to-tcp``:
Convert TCF to TCP

RefBackendPasses
==============================

.. raw:: html

   <!-- Autogenerated by mlir-tblgen; don't manually edit -->

``-lower-alloc-memref-ops``: Lower AllocMemRefOp's
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``-lower-to-refbackrt-abi``: Lower constructs requiring runtime support to ``refbackrt``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We have a specialized dialect ``refbackrt`` which models our runtime's
data structures, and function signatures (and presumably eventually,
other ABI boundaries like external calls if we ever support it) will be
converted.

The constructs requiring runtime support are: - function signatures /
module metadata - error handling ### ``-refback-lower-to-llvm``: Lower
everything to LLVM ### ``-restricted-canonicalize``: Canonicalize
operations This pass is the same as the regular ``canonicalize`` pass,
but it only applies a restricted set of patterns.

This is useful when a particular canonicalization is actually needed for
correctness of a lowering flow. For such cases, running a restricted set
of canonicalizations makes it clearer which passes are needed for
correctness and which passes are "just optimizations". This helps when
debugging miscompiles and other situations where the compiler is not
behaving as expected.

Options
^^^^^^^

::

    -included-dialects : Which dialects should be canonicalized

Transforms
==============================

.. raw:: html

   <!-- Autogenerated by mlir-tblgen; don't manually edit -->

``-basicpy-type-inference``: Performs function level type inference
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CHOPPERNumpyTransforms
==============================

.. raw:: html

   <!-- Autogenerated by mlir-tblgen; don't manually edit -->

``-numpy-array-to-tensor``: Replace arrays with tensors where possible (optimization only).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This pass is analogous to an SSA-formation pass in a traditional
compiler, with the added complication that arrays can alias each other
in interesting ways.

The current code doesn't implement any fancy algorithm, and is intended
to be just sufficient for a first e2e spike. An algorithm inspired by
the SSA formation literature will need to be implemented.

Also, this pass doesn't currently handle interprocedural rewriting (of
private functions), which is even more complex. ###
``-numpy-public-functions-to-tensor``: Converts public functions to
operate on tensors (instead of ndarray) ###
``-numpy-refine-public-return``: Refine public return Refines types of
values return from public functions based on intraprocedural
information.

This pass effectively encodes an assumption by the pass pipeline author
that the public calling convention of the module can have its types
refined, without causing ABI mismatches. This is frequently true -- for
example, in many systems, ``tensor<?x?xf32>``, ``tensor<3x3xf32>`` and
``tensor<*x!numpy.any_dtype>`` are all the same data structure on
calling convention boundaries.

This pass is expected to run after shape refinement has occurred to
otherwise resolve shapes, and is currently mainly useful to convert
rank/dtype-erased function boundaries to ranked, dtyped code for
compiler backends.

CHOPPERTCFTransforms
==============================

.. raw:: html

   <!-- Autogenerated by mlir-tblgen; don't manually edit -->

``-tcf-shape-refinement``: Refines shapes of tensors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CHOPPERTCPTransforms
==============================

.. raw:: html

   <!-- Autogenerated by mlir-tblgen; don't manually edit -->

``-tcp-bufferize``: Bufferizes the tcp dialect
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

